#!/usr/bin/env Rscript
#
# Copyright 2015 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Reads map files, report files, and RAPPOR parameters to run
# an EM algorithm to estimate joint distribution over two or more variables
#
# Usage:
#       $ ./analyze_assoc.R -map1 map_1.csv -map2 map_2.csv \
#                                 -reports reports.csv \
# Inputs: map1, map2, reports, params
#         see how options are parsed below for more information
# Outputs:
#         prints a table with estimated joint probability masses
#         over candidate strings
#         Ex.
#                 ssl   nossl
#         intel   0.1   0.3
#         google  0.5   0.1

library("optparse")

options(stringsAsFactors = FALSE)

if(!interactive()) {
  option_list <- list(
    # Flags
    make_option(c("--map1", "-m1"), default = "map_1.csv",
                help = "Hashed candidates for 1st variable"),
    make_option(c("--map2", "-m2"), default = "map_2.csv",
                help = "Hashed candidates for 2nd variable"),
    make_option(c("--reports", "-r"), default = "reports.csv",
                help = "File with raw reports as <cohort, report1, report2>"),
    make_option(c("--truefile", "-t"), default = "truedist.csv",
                help = "File with true distribution generated by assoc_sim.R"),
    make_option(c("--outdir", "-o"), default = ".",
                help = "File where the metrics go"),
    make_option(c("--params", "-p"), default = "params.csv",
                help = "Filename for RAPPOR parameters")
  )
  opts <- parse_args(OptionParser(option_list = option_list))
}

source("analysis/R/encode.R")
source("analysis/R/decode.R")
source("analysis/R/simulation.R")
source("analysis/R/read_input.R")
source("analysis/R/association.R")

# This function processes the maps loaded using ReadMapFile
# Association analysis requires a map object with a map
# field that has the map split into cohorts and an rmap field
# that has all the cohorts combined
# Arguments:
#       map = map object with cohorts as sparse matrix in
#             object map$map
#             This is the expected object from ReadMapFile
#       params = data field with parameters
# TODO(pseudorandom): move this functionality to ReadMapFile
ProcessMap <- function(map, params) {
  map$rmap <- map$map
  split_map <- function(i, map_struct) {
    numbits <- params$k
    indices <- which(as.matrix(
      map_struct[((i - 1) * numbits + 1):(i * numbits),]) == TRUE,
      arr.ind = TRUE)
    sparseMatrix(indices[, "row"], indices[, "col"],
                 dims = c(numbits, max(indices[, "col"])))
  }
  map$map <- lapply(1:params$m, function(i) split_map(i, map$rmap))
  map
}

main <- function(opts) {
  ptm <- proc.time()

  params <- ReadParameterFile(opts$params)
  opts_map <- list(opts$map1, opts$map2)
  map <- lapply(opts_map, function(o)
                  ProcessMap(ReadMapFile(o, params = params),
                             params = params))
  # Reports must be of the format
  #     cohort no, rappor bitstring 1, rappor bitstring 2
  reportsObj <- read.csv(opts$reports,
                         colClasses = c("integer", "character", "character"),
                         header = FALSE)

  # Parsing reportsObj
  # ComputeDistributionEM allows for different sets of cohorts
  # for each variable. Here, both sets of cohorts are identical
  co <- as.list(reportsObj[1])[[1]]
  cohorts <- list(co, co)
  # Parse reports from reportObj cols 2 and 3
  reports <- lapply(1:2, function(x) as.list(reportsObj[x + 1]))

  # Split strings into bit arrays (as required by assoc analysis)
  reports <- lapply(1:2, function(i) {
    # apply the following function to each of reports[[1]] and reports[[2]]
    lapply(reports[[i]][[1]], function(x) {
      # function splits strings and converts them to numeric values
      as.numeric(strsplit(x, split = "")[[1]])
    })
  })

  joint_dist <- ComputeDistributionEM(reports, cohorts, map,
                                      ignore_other = TRUE,
                                      params, marginals = NULL,
                                      estimate_var = FALSE)

  td <- read.csv(file = opts$truefile)
  ed <- joint_dist$fit
  print("CHI-SQUARED")
  td_chisq <- chisq.test(td)
  ed_chisq <- chisq.test(ed)
  print(td_chisq)
  print(ed_chisq)

  # L1 distance = 1 - sum(min(td|x, ed|x)) where
  # td|x / ed|x projects the distribution to the intersection x of the
  # supports of td and ed
  rowsi <- intersect(rownames(td), rownames(ed))
  colsi <- intersect(colnames(td), colnames(ed))
  print("L1 DISTANCE")
  l1d <- 1 - sum(mapply(min,
                  unlist(td[rowsi, colsi], use.names = FALSE),
                  unlist(as.data.frame(ed)[rowsi, colsi], use.names = FALSE)
                   ))
  print(l1d)

  print("JOINT_DIST$FIT")
  print(signif(ed[order(rowSums(ed)),], 4))
  print("PROC.TIME")
  time_taken <- proc.time() - ptm
  print(time_taken)

  # Write metrics to metrics.csv
  metrics <- list(td_chisq = td_chisq[1][[1]][[1]],
                  ed_chisq = ed_chisq[1][[1]][[1]],
                 tv = l1d/2, time = time_taken[2])   # report l1 distance / 2
                                                     # to be consistent with
                                                     # histogram analysis
  filename <- file.path(opts$outdir, 'metrics.csv')
  write.csv(metrics, file = filename, row.names = FALSE)
}

if(!interactive()) {
