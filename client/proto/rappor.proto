package rappor;

// These collection parameters must be known to the RAPPOR analysis code.
message EncodingParams {
  optional int32 num_bits = 1;  // k
  optional int32 num_hashes = 2;  // h

  // NOTE: The client does NOT need this.  Client gets a single cohort.  Only
  // analysis needs it.
  //optional int32 num_cohorts = 3;  // m

  // TODO: Name of hash function?
}
enum FieldType {
  STRING = 0;
  ORDINAL = 1;
  BOOLEAN = 2;
}

// A single observation, which may contain multiple variables encoded reported
// together.

message Report {
  // RAPPOR report.
  repeated uint64 bits = 2;

  // Schema ID?
  // or field num, report?
  //
  // field num, param ID, report?

  // field ID?
}

message ReportList {
  // NOTE: These could be of heterogeneous types.  So should each report
  // contain a schema identifier?  That's probably the easiest.
  repeated Report report = 1;

  // Header fields
  optional int32 cohort = 2;

  // optional EncodingParams params = 2;
  // Stuff about schema can be here, e.g. params

  // RecordSchema could populate this directly?
  // Or you can put an application-specific integer ID, to save size.
}

// Hierarchy:

// Big list of various report types (like Chrome has).  To save space.
// I guess that is ReportList.  They can be same or different.
//
// Cohort goes in here.


// ReportSet.  Multiple reports that have to go message?
// How do you identify them?
// By the schema?

// RecordReport - the thing that Encode() of message gives you

// FieldReport - individual fields.  Just uint64?  Type is in schema.

